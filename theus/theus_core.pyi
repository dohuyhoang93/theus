from typing import Any, Optional, List, Dict


class AuditAbortError:
    def __init__(self, /, *args, **kwargs): ...

class AuditBlockError:
    def __init__(self, /, *args, **kwargs): ...

class AuditLevel:
    def __init__(self, /, *args, **kwargs): ...

class AuditLogEntry:
    def __init__(self, /, *args, **kwargs): ...

class AuditRecipe:
    def __init__(self, /, *args, **kwargs): ...

class AuditStopError:
    def __init__(self, /, *args, **kwargs): ...

class AuditSystem:
    def __init__(self, /, *args, **kwargs): ...
    def get_count(self, /, key): ...
    def get_count_all(self, /): ...
    def get_logs(self, /): ...
    def log(self, /, key, message): ...
    def log_fail(self, /, key, level=None, threshold_max=None): ...
    def log_success(self, /, key): ...

class AuditWarning:
    def __init__(self, /, *args, **kwargs): ...

class ConfigLoader:
    def __init__(self, /, *args, **kwargs): ...
    def load_from_string(content): ...

class ConflictManager:
    def __init__(self, /, *args, **kwargs): ...
    def get_failure_count(self, /, key): ...
    def is_blocked(self, /, requester=None): ...
    def report_conflict(self, /, key): ...
    def report_success(self, /, key): ...

class ContextError:
    def __init__(self, /, *args, **kwargs): ...

class ContextGuard:
    def __init__(self, /, *args, **kwargs): ...
    def _elevate(self, /, enabled): ...
    def log(self, /, message): ...

class FSMState:
    def __init__(self, /, *args, **kwargs): ...

class FrozenDict:
    def __init__(self, /, *args, **kwargs): ...
    def get(self, /, key, default=None): ...
    def items(self, /): ...
    def keys(self, /): ...
    def to_dict(self, /): ...
    def values(self, /): ...

class MetaLogEntry:
    def __init__(self, /, *args, **kwargs): ...

class OutboxCollector:
    def __init__(self, /, *args, **kwargs): ...
    def add(self, /, msg): ...
    def drain(self, /): ...
    def len(self, /): ...

class OutboxMsg:
    def __init__(self, /, *args, **kwargs): ...

class ProcessContext:
    def __init__(self, /, *args, **kwargs): ...

class RetryDecision:
    def __init__(self, /, *args, **kwargs): ...

class SchemaViolationError:
    def __init__(self, /, *args, **kwargs): ...

class SignalHub:
    def __init__(self, /, *args, **kwargs): ...
    def publish(self, /, msg): ...
    def subscribe(self, /): ...

class SignalReceiver:
    def __init__(self, /, *args, **kwargs): ...
    def recv(self, /): ...
    def recv_async(self, /): ...

class State:
    def __init__(self, /, *args, **kwargs): ...
    def domain_proxy(self, /, read_only=None): ...
    def get_meta_logs(self, /): ...
    def log_meta(self, /, key, message): ...
    def restrict_view(self, /): ...
    def update(self, /, data=None, heavy=None, signal=None): ...

class SupervisorCore:
    def __init__(self, /, *args, **kwargs): ...
    def contains(self, /, key): ...
    def get_version(self, /, key): ...
    def keys(self, /): ...
    def read(self, /, key): ...
    def remove(self, /, key): ...
    def write(self, /, key, val): ...

class SupervisorProxy:
    def __init__(self, /, *args, **kwargs): ...
    def _set_capabilities(self, /, caps): ...
    def _wrap_result(self, /, key_or_path, val): ...
    def append(self, /, item): ...
    def clear(self, /): ...
    def extend(self, /, iterable): ...
    def get(self, /, key, default=None): ...
    def insert(self, /, index, item): ...
    def is_proxy(self, /): ...
    def items(self, /): ...
    def keys(self, /): ...
    def path(self, /): ...
    def pop(self, /, key_or_index=None, default=None): ...
    def popitem(self, /): ...
    def remove(self, /, value): ...
    def reverse(self, /): ...
    def setdefault(self, /, key, default=None): ...
    def sort(self, /, kwargs=None): ...
    def to_dict(self, /): ...
    def update(self, /, other=None, kwargs=None): ...
    def values(self, /): ...

class TheusEngine:
    def __init__(self, /, *args, **kwargs): ...
    def attach_worker(self, /, worker): ...
    def commit_state(self, /, state): ...
    def compare_and_swap(self, /, expected_version, data=None, heavy=None, signal=None, requester=None): ...
    def execute_process_async(self, /, name, func, tx=None): ...
    def process_outbox(self, /): ...
    def report_conflict(self, /, process_name): ...
    def report_success(self, /, process_name): ...
    def set_audit_system(self, /, audit): ...
    def set_schema(self, /, schema): ...
    def set_strict_cas(self, /, enabled): ...
    def set_strict_guards(self, /, enabled): ...
    def transaction(self, /, write_timeout_ms=5000): ...

class Transaction:
    def __enter__(self, /): ...
    def __exit__(self, /, _exc_type=None, _exc_value=None, _traceback=None): ...
    def __init__(self, /, *args, **kwargs): ...
    def build_pending_from_deltas(self, /): ...
    def commit(self, /): ...
    def flush_outbox(self, /): ...
    def get_delta_log(self, /): ...
    def get_shadow(self, /, val, path=None): ...
    def get_shadow_updates(self, /): ...
    def infer_shadow_deltas(self, /): ...
    def is_known_shadow(self, /, obj): ...
    def log_delta(self, /, path, old_val=None, new_val=None): ...
    def log_internal(self, /, _path, _op, _new_val=None, _old_val=None, _obj_ref=None, _key=None): ...
    def update(self, /, data=None, heavy=None, signal=None): ...

class WorkflowEngine:
    def __init__(self, /, *args, **kwargs): ...
    def add_state_observer(self, /, callback): ...
    def execute(self, /, ctx, executor): ...
    def execute_async(self, /, ctx, executor): ...
    def simulate(self, /, ctx): ...

class WriteTimeoutError:
    def __init__(self, /, *args, **kwargs): ...
