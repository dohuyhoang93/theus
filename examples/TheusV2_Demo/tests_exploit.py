import pytest
import time
import logging
from theus import POPEngine
from theus.orchestrator import ThreadExecutor, SignalBus, WorkflowManager
from src.context import DemoSystemContext
from src.processes.stress import p_unsafe_write

# Setup
logging.basicConfig(level=logging.ERROR) # Only show Errors

def run_write_test(strict: bool):
    """
    Helper to run p_unsafe_write and return final status.
    """
    sys = DemoSystemContext()
    engine = POPEngine(sys, strict_mode=strict)
    engine.register_process("p_unsafe_write", p_unsafe_write)
    
    # Execute directly via Engine to test Core Protection (skipping Orchestrator overhead)
    # Note: p_unsafe_write catches exception and returns "Blocked".
    # But if strict=False, it might NOT raise exception? 
    # Let's check p_unsafe_write logic.
    
    print(f"\n[TEST MODE] Strict={strict}")
    try:
        engine.execute_process("p_unsafe_write")
    except Exception as e:
        print(f"   Exception Caught: {e}")
        
    return sys.domain_ctx.status

def test_vulnerable_without_strict_mode():
    """
    PROOF 1: If Strict Mode is OFF, Theus should allow the write (Vulnerable).
    """
    print("\n--- Test A: Vulnerable Mode (Strict=False) ---")
    final_status = run_write_test(strict=False)
    print(f"   Final Status: {final_status}")
    
    # Expectation: Mutation SUCCEEDED
    assert final_status == "HACKED"
    print("   -> PROOF: Without protection, Hack succeeded.")

def test_protected_with_strict_mode():
    """
    PROOF 2: If Strict Mode is ON, Theus must BLOCK the write.
    """
    print("\n--- Test B: Protected Mode (Strict=True) ---")
    final_status = run_write_test(strict=True)
    print(f"   Final Status: {final_status}")
    
    # Expectation: Mutation FAILED (Blocked)
    assert final_status == "READY" # Default
    print("   -> PROOF: With protection, Hack was blocked.")

